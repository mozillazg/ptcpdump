// Code generated by bpf2go; DO NOT EDIT.
//go:build arm

package bpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadBpf_no_tracing returns the embedded CollectionSpec for bpf_no_tracing.
func loadBpf_no_tracing() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_Bpf_no_tracingBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load bpf_no_tracing: %w", err)
	}

	return spec, err
}

// loadBpf_no_tracingObjects loads bpf_no_tracing and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*bpf_no_tracingObjects
//	*bpf_no_tracingPrograms
//	*bpf_no_tracingMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBpf_no_tracingObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBpf_no_tracing()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// bpf_no_tracingSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpf_no_tracingSpecs struct {
	bpf_no_tracingProgramSpecs
	bpf_no_tracingMapSpecs
	bpf_no_tracingVariableSpecs
}

// bpf_no_tracingProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpf_no_tracingProgramSpecs struct {
	PtcpdumpCgroupConnect4                   *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__connect4"`
	PtcpdumpCgroupConnect6                   *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__connect6"`
	PtcpdumpCgroupPostBind4                  *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__post_bind4"`
	PtcpdumpCgroupPostBind6                  *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__post_bind6"`
	PtcpdumpCgroupRecvmsg4                   *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__recvmsg4"`
	PtcpdumpCgroupRecvmsg6                   *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__recvmsg6"`
	PtcpdumpCgroupSendmsg4                   *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__sendmsg4"`
	PtcpdumpCgroupSendmsg6                   *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__sendmsg6"`
	PtcpdumpCgroupSockCreate                 *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__sock_create"`
	PtcpdumpCgroupSockRelease                *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup__sock_release"`
	PtcpdumpCgroupSkbEgress                  *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup_skb__egress"`
	PtcpdumpCgroupSkbIngress                 *ebpf.ProgramSpec `ebpf:"ptcpdump_cgroup_skb__ingress"`
	PtcpdumpKprobeAcctProcess                *ebpf.ProgramSpec `ebpf:"ptcpdump_kprobe__acct_process"`
	PtcpdumpKprobeDoExit                     *ebpf.ProgramSpec `ebpf:"ptcpdump_kprobe__do_exit"`
	PtcpdumpKprobeSecuritySkClassifyFlow     *ebpf.ProgramSpec `ebpf:"ptcpdump_kprobe__security_sk_classify_flow"`
	PtcpdumpKprobeTcpSendmsg                 *ebpf.ProgramSpec `ebpf:"ptcpdump_kprobe__tcp_sendmsg"`
	PtcpdumpKprobeUdpSendSkb                 *ebpf.ProgramSpec `ebpf:"ptcpdump_kprobe__udp_send_skb"`
	PtcpdumpKprobeUdpSendmsg                 *ebpf.ProgramSpec `ebpf:"ptcpdump_kprobe__udp_sendmsg"`
	PtcpdumpRawTracepointSchedProcessExec    *ebpf.ProgramSpec `ebpf:"ptcpdump_raw_tracepoint__sched_process_exec"`
	PtcpdumpRawTracepointSchedProcessExit    *ebpf.ProgramSpec `ebpf:"ptcpdump_raw_tracepoint__sched_process_exit"`
	PtcpdumpRawTracepointSchedProcessFork    *ebpf.ProgramSpec `ebpf:"ptcpdump_raw_tracepoint__sched_process_fork"`
	PtcpdumpTcEgress                         *ebpf.ProgramSpec `ebpf:"ptcpdump_tc_egress"`
	PtcpdumpTcIngress                        *ebpf.ProgramSpec `ebpf:"ptcpdump_tc_ingress"`
	PtcpdumpTracepointSchedProcessExec       *ebpf.ProgramSpec `ebpf:"ptcpdump_tracepoint__sched_process_exec"`
	PtcpdumpUprobeGoBuiltinTlsWriteKeyLog    *ebpf.ProgramSpec `ebpf:"ptcpdump_uprobe__go_builtin__tls__write_key_log"`
	PtcpdumpUprobeGoBuiltinTlsWriteKeyLogRet *ebpf.ProgramSpec `ebpf:"ptcpdump_uprobe__go_builtin__tls__write_key_log__ret"`
}

// bpf_no_tracingMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpf_no_tracingMapSpecs struct {
	PtcpdumpConfigMap                 *ebpf.MapSpec `ebpf:"ptcpdump_config_map"`
	PtcpdumpExecEventStack            *ebpf.MapSpec `ebpf:"ptcpdump_exec_event_stack"`
	PtcpdumpExecEvents                *ebpf.MapSpec `ebpf:"ptcpdump_exec_events"`
	PtcpdumpExitEventTmp              *ebpf.MapSpec `ebpf:"ptcpdump_exit_event_tmp"`
	PtcpdumpExitEvents                *ebpf.MapSpec `ebpf:"ptcpdump_exit_events"`
	PtcpdumpExitEventsRingbuf         *ebpf.MapSpec `ebpf:"ptcpdump_exit_events_ringbuf"`
	PtcpdumpFilterByKernelCount       *ebpf.MapSpec `ebpf:"ptcpdump_filter_by_kernel_count"`
	PtcpdumpFilterIfindexMap          *ebpf.MapSpec `ebpf:"ptcpdump_filter_ifindex_map"`
	PtcpdumpFilterMntnsMap            *ebpf.MapSpec `ebpf:"ptcpdump_filter_mntns_map"`
	PtcpdumpFilterNetnsMap            *ebpf.MapSpec `ebpf:"ptcpdump_filter_netns_map"`
	PtcpdumpFilterPidMap              *ebpf.MapSpec `ebpf:"ptcpdump_filter_pid_map"`
	PtcpdumpFilterPidnsMap            *ebpf.MapSpec `ebpf:"ptcpdump_filter_pidns_map"`
	PtcpdumpFilterUidMap              *ebpf.MapSpec `ebpf:"ptcpdump_filter_uid_map"`
	PtcpdumpFlowPidMap                *ebpf.MapSpec `ebpf:"ptcpdump_flow_pid_map"`
	PtcpdumpGoKeylogBufStorage        *ebpf.MapSpec `ebpf:"ptcpdump_go_keylog_buf_storage"`
	PtcpdumpGoKeylogEventTmp          *ebpf.MapSpec `ebpf:"ptcpdump_go_keylog_event_tmp"`
	PtcpdumpGoKeylogEvents            *ebpf.MapSpec `ebpf:"ptcpdump_go_keylog_events"`
	PtcpdumpGoKeylogEventsRingbuf     *ebpf.MapSpec `ebpf:"ptcpdump_go_keylog_events_ringbuf"`
	PtcpdumpPacketEventStack          *ebpf.MapSpec `ebpf:"ptcpdump_packet_event_stack"`
	PtcpdumpPacketEvents              *ebpf.MapSpec `ebpf:"ptcpdump_packet_events"`
	PtcpdumpPacketEventsRingbuf       *ebpf.MapSpec `ebpf:"ptcpdump_packet_events_ringbuf"`
	PtcpdumpPtcpdumpExecEventsRingbuf *ebpf.MapSpec `ebpf:"ptcpdump_ptcpdump_exec_events_ringbuf"`
	PtcpdumpSockCookiePidMap          *ebpf.MapSpec `ebpf:"ptcpdump_sock_cookie_pid_map"`
}

// bpf_no_tracingVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpf_no_tracingVariableSpecs struct {
	G        *ebpf.VariableSpec `ebpf:"g"`
	Unused1  *ebpf.VariableSpec `ebpf:"unused1"`
	Unused12 *ebpf.VariableSpec `ebpf:"unused12"`
	Unused13 *ebpf.VariableSpec `ebpf:"unused13"`
	Unused14 *ebpf.VariableSpec `ebpf:"unused14"`
	Unused2  *ebpf.VariableSpec `ebpf:"unused2"`
	Unused3  *ebpf.VariableSpec `ebpf:"unused3"`
	Unused4  *ebpf.VariableSpec `ebpf:"unused4"`
	Unused5  *ebpf.VariableSpec `ebpf:"unused5"`
	Unused6  *ebpf.VariableSpec `ebpf:"unused6"`
	Unused7  *ebpf.VariableSpec `ebpf:"unused7"`
}

// bpf_no_tracingObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBpf_no_tracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpf_no_tracingObjects struct {
	bpf_no_tracingPrograms
	bpf_no_tracingMaps
	bpf_no_tracingVariables
}

func (o *bpf_no_tracingObjects) Close() error {
	return _Bpf_no_tracingClose(
		&o.bpf_no_tracingPrograms,
		&o.bpf_no_tracingMaps,
	)
}

// bpf_no_tracingMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBpf_no_tracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpf_no_tracingMaps struct {
	PtcpdumpConfigMap                 *ebpf.Map `ebpf:"ptcpdump_config_map"`
	PtcpdumpExecEventStack            *ebpf.Map `ebpf:"ptcpdump_exec_event_stack"`
	PtcpdumpExecEvents                *ebpf.Map `ebpf:"ptcpdump_exec_events"`
	PtcpdumpExitEventTmp              *ebpf.Map `ebpf:"ptcpdump_exit_event_tmp"`
	PtcpdumpExitEvents                *ebpf.Map `ebpf:"ptcpdump_exit_events"`
	PtcpdumpExitEventsRingbuf         *ebpf.Map `ebpf:"ptcpdump_exit_events_ringbuf"`
	PtcpdumpFilterByKernelCount       *ebpf.Map `ebpf:"ptcpdump_filter_by_kernel_count"`
	PtcpdumpFilterIfindexMap          *ebpf.Map `ebpf:"ptcpdump_filter_ifindex_map"`
	PtcpdumpFilterMntnsMap            *ebpf.Map `ebpf:"ptcpdump_filter_mntns_map"`
	PtcpdumpFilterNetnsMap            *ebpf.Map `ebpf:"ptcpdump_filter_netns_map"`
	PtcpdumpFilterPidMap              *ebpf.Map `ebpf:"ptcpdump_filter_pid_map"`
	PtcpdumpFilterPidnsMap            *ebpf.Map `ebpf:"ptcpdump_filter_pidns_map"`
	PtcpdumpFilterUidMap              *ebpf.Map `ebpf:"ptcpdump_filter_uid_map"`
	PtcpdumpFlowPidMap                *ebpf.Map `ebpf:"ptcpdump_flow_pid_map"`
	PtcpdumpGoKeylogBufStorage        *ebpf.Map `ebpf:"ptcpdump_go_keylog_buf_storage"`
	PtcpdumpGoKeylogEventTmp          *ebpf.Map `ebpf:"ptcpdump_go_keylog_event_tmp"`
	PtcpdumpGoKeylogEvents            *ebpf.Map `ebpf:"ptcpdump_go_keylog_events"`
	PtcpdumpGoKeylogEventsRingbuf     *ebpf.Map `ebpf:"ptcpdump_go_keylog_events_ringbuf"`
	PtcpdumpPacketEventStack          *ebpf.Map `ebpf:"ptcpdump_packet_event_stack"`
	PtcpdumpPacketEvents              *ebpf.Map `ebpf:"ptcpdump_packet_events"`
	PtcpdumpPacketEventsRingbuf       *ebpf.Map `ebpf:"ptcpdump_packet_events_ringbuf"`
	PtcpdumpPtcpdumpExecEventsRingbuf *ebpf.Map `ebpf:"ptcpdump_ptcpdump_exec_events_ringbuf"`
	PtcpdumpSockCookiePidMap          *ebpf.Map `ebpf:"ptcpdump_sock_cookie_pid_map"`
}

func (m *bpf_no_tracingMaps) Close() error {
	return _Bpf_no_tracingClose(
		m.PtcpdumpConfigMap,
		m.PtcpdumpExecEventStack,
		m.PtcpdumpExecEvents,
		m.PtcpdumpExitEventTmp,
		m.PtcpdumpExitEvents,
		m.PtcpdumpExitEventsRingbuf,
		m.PtcpdumpFilterByKernelCount,
		m.PtcpdumpFilterIfindexMap,
		m.PtcpdumpFilterMntnsMap,
		m.PtcpdumpFilterNetnsMap,
		m.PtcpdumpFilterPidMap,
		m.PtcpdumpFilterPidnsMap,
		m.PtcpdumpFilterUidMap,
		m.PtcpdumpFlowPidMap,
		m.PtcpdumpGoKeylogBufStorage,
		m.PtcpdumpGoKeylogEventTmp,
		m.PtcpdumpGoKeylogEvents,
		m.PtcpdumpGoKeylogEventsRingbuf,
		m.PtcpdumpPacketEventStack,
		m.PtcpdumpPacketEvents,
		m.PtcpdumpPacketEventsRingbuf,
		m.PtcpdumpPtcpdumpExecEventsRingbuf,
		m.PtcpdumpSockCookiePidMap,
	)
}

// bpf_no_tracingVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadBpf_no_tracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpf_no_tracingVariables struct {
	G        *ebpf.Variable `ebpf:"g"`
	Unused1  *ebpf.Variable `ebpf:"unused1"`
	Unused12 *ebpf.Variable `ebpf:"unused12"`
	Unused13 *ebpf.Variable `ebpf:"unused13"`
	Unused14 *ebpf.Variable `ebpf:"unused14"`
	Unused2  *ebpf.Variable `ebpf:"unused2"`
	Unused3  *ebpf.Variable `ebpf:"unused3"`
	Unused4  *ebpf.Variable `ebpf:"unused4"`
	Unused5  *ebpf.Variable `ebpf:"unused5"`
	Unused6  *ebpf.Variable `ebpf:"unused6"`
	Unused7  *ebpf.Variable `ebpf:"unused7"`
}

// bpf_no_tracingPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBpf_no_tracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpf_no_tracingPrograms struct {
	PtcpdumpCgroupConnect4                   *ebpf.Program `ebpf:"ptcpdump_cgroup__connect4"`
	PtcpdumpCgroupConnect6                   *ebpf.Program `ebpf:"ptcpdump_cgroup__connect6"`
	PtcpdumpCgroupPostBind4                  *ebpf.Program `ebpf:"ptcpdump_cgroup__post_bind4"`
	PtcpdumpCgroupPostBind6                  *ebpf.Program `ebpf:"ptcpdump_cgroup__post_bind6"`
	PtcpdumpCgroupRecvmsg4                   *ebpf.Program `ebpf:"ptcpdump_cgroup__recvmsg4"`
	PtcpdumpCgroupRecvmsg6                   *ebpf.Program `ebpf:"ptcpdump_cgroup__recvmsg6"`
	PtcpdumpCgroupSendmsg4                   *ebpf.Program `ebpf:"ptcpdump_cgroup__sendmsg4"`
	PtcpdumpCgroupSendmsg6                   *ebpf.Program `ebpf:"ptcpdump_cgroup__sendmsg6"`
	PtcpdumpCgroupSockCreate                 *ebpf.Program `ebpf:"ptcpdump_cgroup__sock_create"`
	PtcpdumpCgroupSockRelease                *ebpf.Program `ebpf:"ptcpdump_cgroup__sock_release"`
	PtcpdumpCgroupSkbEgress                  *ebpf.Program `ebpf:"ptcpdump_cgroup_skb__egress"`
	PtcpdumpCgroupSkbIngress                 *ebpf.Program `ebpf:"ptcpdump_cgroup_skb__ingress"`
	PtcpdumpKprobeAcctProcess                *ebpf.Program `ebpf:"ptcpdump_kprobe__acct_process"`
	PtcpdumpKprobeDoExit                     *ebpf.Program `ebpf:"ptcpdump_kprobe__do_exit"`
	PtcpdumpKprobeSecuritySkClassifyFlow     *ebpf.Program `ebpf:"ptcpdump_kprobe__security_sk_classify_flow"`
	PtcpdumpKprobeTcpSendmsg                 *ebpf.Program `ebpf:"ptcpdump_kprobe__tcp_sendmsg"`
	PtcpdumpKprobeUdpSendSkb                 *ebpf.Program `ebpf:"ptcpdump_kprobe__udp_send_skb"`
	PtcpdumpKprobeUdpSendmsg                 *ebpf.Program `ebpf:"ptcpdump_kprobe__udp_sendmsg"`
	PtcpdumpRawTracepointSchedProcessExec    *ebpf.Program `ebpf:"ptcpdump_raw_tracepoint__sched_process_exec"`
	PtcpdumpRawTracepointSchedProcessExit    *ebpf.Program `ebpf:"ptcpdump_raw_tracepoint__sched_process_exit"`
	PtcpdumpRawTracepointSchedProcessFork    *ebpf.Program `ebpf:"ptcpdump_raw_tracepoint__sched_process_fork"`
	PtcpdumpTcEgress                         *ebpf.Program `ebpf:"ptcpdump_tc_egress"`
	PtcpdumpTcIngress                        *ebpf.Program `ebpf:"ptcpdump_tc_ingress"`
	PtcpdumpTracepointSchedProcessExec       *ebpf.Program `ebpf:"ptcpdump_tracepoint__sched_process_exec"`
	PtcpdumpUprobeGoBuiltinTlsWriteKeyLog    *ebpf.Program `ebpf:"ptcpdump_uprobe__go_builtin__tls__write_key_log"`
	PtcpdumpUprobeGoBuiltinTlsWriteKeyLogRet *ebpf.Program `ebpf:"ptcpdump_uprobe__go_builtin__tls__write_key_log__ret"`
}

func (p *bpf_no_tracingPrograms) Close() error {
	return _Bpf_no_tracingClose(
		p.PtcpdumpCgroupConnect4,
		p.PtcpdumpCgroupConnect6,
		p.PtcpdumpCgroupPostBind4,
		p.PtcpdumpCgroupPostBind6,
		p.PtcpdumpCgroupRecvmsg4,
		p.PtcpdumpCgroupRecvmsg6,
		p.PtcpdumpCgroupSendmsg4,
		p.PtcpdumpCgroupSendmsg6,
		p.PtcpdumpCgroupSockCreate,
		p.PtcpdumpCgroupSockRelease,
		p.PtcpdumpCgroupSkbEgress,
		p.PtcpdumpCgroupSkbIngress,
		p.PtcpdumpKprobeAcctProcess,
		p.PtcpdumpKprobeDoExit,
		p.PtcpdumpKprobeSecuritySkClassifyFlow,
		p.PtcpdumpKprobeTcpSendmsg,
		p.PtcpdumpKprobeUdpSendSkb,
		p.PtcpdumpKprobeUdpSendmsg,
		p.PtcpdumpRawTracepointSchedProcessExec,
		p.PtcpdumpRawTracepointSchedProcessExit,
		p.PtcpdumpRawTracepointSchedProcessFork,
		p.PtcpdumpTcEgress,
		p.PtcpdumpTcIngress,
		p.PtcpdumpTracepointSchedProcessExec,
		p.PtcpdumpUprobeGoBuiltinTlsWriteKeyLog,
		p.PtcpdumpUprobeGoBuiltinTlsWriteKeyLogRet,
	)
}

func _Bpf_no_tracingClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed bpf_no_tracing_arm_bpfel.o
var _Bpf_no_tracingBytes []byte
